准备
- java
	- 基本知识
		- 特性
			- 泛型中? super T和? extends T的区别 [参考](http://ifeve.com/difference-between-super-t-and-extends-t-in-java/)
			-  [参考](http://ifeve.com/difference-between-super-t-and-extends-t-in-java/)
		- 关键字
			- default
			- transient
		- 箭头函数
			- 结构
				- 一个 Lambda 表达式可以有零个或多个参数
				- 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同
				- 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)
				- 空圆括号代表参数集为空。例如：() -> 42
				- 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -> return a * a
				- Lambda 表达式的主体可包含零条或多条语句
				- 如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空
			- 什么是函数式接口    
			在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。   
            java.lang.Runnable 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 void run()，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。   
            每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。
            ```
            Runnable r = () -> System.out.println("hello world");
            ```
            当不指明函数式接口时，编译器会自动解释这种转化：
            ```
            new Thread(
            	() -> System.out.println("hello world")
            ).start();
            ```
            因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 public Thread(Runnable r) { }，将该 Lambda 表达式赋给 Runnable 接口。以下是一些 Lambda 表达式及其函数式接口：    
            ```
            Consumer<Integer>  c = (int x) -> { System.out.println(x) };
            BiConsumer<Integer, String> b = (Integer x, String y) -> System.out.println(x + " : " + y);
            Predicate<String> p = (String s) -> { s == null };
            ```
            更多参考[深入浅出 Java 8 Lambda 表达式](http://blog.oneapm.com/apm-tech/226.html)
		- 静态类与单例模式的区别
		- 接口和抽象类的区别
		- 类的加载过程，如果你的包里也有java包，虚拟机如何辨别
			- 就静态代码段啊构造函数之类的加载顺序
		- 对HashMap的认识？hashmap的初始容量及每次扩容因子？
		- HashMap是否是线程安全？ 为什么？
		- hashmap和concurrenthashmap
	- IO
	- 多线程
		- 线程安全的原理和实现安全
			-  synchronized，reentrantlock，volatile（重点） 
			-  想实现一个线程安全的队列，可以怎么实现？
		- wait和sleep的区别
	- 并发处理
	- 集合和容器
		![继承关系](https://img-blog.csdn.net/20140628144205625) 
		- Iterator（用于单向移动的遍历集合的迭代器）源码分析
		```java
        public interface Iterator<E> {
            boolean hasNext(); 		//是否有下一个元素
            E next();				//返回下一个元素
            //移除并返回元素
            default void remove() {
                throw new UnsupportedOperationException("remove");
            }						//能够将Iterator中迭代剩余的元素传递给一个函数
            default void forEachRemaining(Consumer<? super E> action) {
                Objects.requireNonNull(action);
                while (hasNext())
                    action.accept(next());
            }
        }
        ```
        ```java
        @FunctionalInterface
        public interface Consumer<T> {
            void accept(T t);
            default Consumer<T> andThen(Consumer<? super T> after) {
                Objects.requireNonNull(after);
                return (T t) -> { accept(t); after.accept(t); };
            }
        }
        ```
        [示例](https://blog.csdn.net/Lirx_Tech/article/details/51484703)   
        ```
        ArrayList<String> list = new ArrayList();  
        for (int i = 0; i < 10; i++) {  
            list.add(String.valueOf(i));  
        }  
  
        Iterator iterator = list.iterator();  
        iterator.forEachRemaining(new Consumer() {  
            @Override  
            public void accept(Object o) {  
                System.out.println(o);  
                if (o.equals("3") ) {  
                  System.out.println("remove");  
                  iterator.remove();  			//出错
                }  
            }  
        });  
        ```
       	出错参考：[Java8,iterator的forEachRemaining中remove可能抛异常](https://blog.csdn.net/u011142426/article/details/78894192)
        - 集合
        ![集合](https://img-blog.csdn.net/20160408221840040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 
        - Collection（高度抽象的集合类）源码分析
        ```java
        abstract boolean         add(E object)  
        abstract boolean         addAll(Collection<? extends E> collection)  
        abstract void            clear()  
        abstract boolean         contains(Object object)  
        abstract boolean         containsAll(Collection<?> collection)  
        abstract boolean         equals(Object object)  
        abstract int             hashCode()  
        abstract boolean         isEmpty()  
        abstract Iterator<E>     iterator()  
        abstract boolean         remove(Object object)  
        abstract boolean         removeAll(Collection<?> collection)  
        abstract boolean         retainAll(Collection<?> collection)  
        default boolean          removeIf(Predicate<? super E> filter)	//按条件删除
        abstract int             size()  
        abstract <T> T[]         toArray(T[] array)  
        abstract Object[]        toArray()     

        //删除满足条件的元素
        default boolean removeIf(Predicate<? super E> filter) {
            Objects.requireNonNull(filter);
            boolean removed = false;
            final Iterator<E> each = iterator();
            while (each.hasNext()) {
                if (filter.test(each.next())) {
                    each.remove();
                    removed = true;
                }
            }
            return removed;
        }

        @Override
        default Spliterator<E> spliterator() {
            return Spliterators.spliterator(this, 0);
        }
        
        default Stream<E> stream() {
            return StreamSupport.stream(spliterator(), false);
        }
        
        default Stream<E> parallelStream() {
            return StreamSupport.stream(spliterator(), true);
        }
        ```
        ```java
        @FunctionalInterface
        public interface Predicate<T> {
            boolean test(T t);				//是否符合条件
            default Predicate<T> and(Predicate<? super T> other) {
                Objects.requireNonNull(other);
                return (t) -> test(t) && other.test(t);
            }
            default Predicate<T> negate() {
                return (t) -> !test(t);
            }
            default Predicate<T> or(Predicate<? super T> other) {
                Objects.requireNonNull(other);
                return (t) -> test(t) || other.test(t);
            }
            static <T> Predicate<T> isEqual(Object targetRef) {
                return (null == targetRef)
                        ? Objects::isNull
                        : object -> targetRef.equals(object);
            }
        }
        ```
		- List 源码分析   
			- 有序列表，因为每个元素都有数字下标
		```java
        public interface List<E> extends Collection<E> {
            int 			size();
            boolean 		isEmpty();
            boolean 		contains(Object o);
            Iterator<E> 	iterator();
            Object[] 		toArray();
            <T> T[] 		toArray(T[] a);
            boolean 		add(E e);
            boolean 		remove(Object o);
            boolean 		containsAll(Collection<?> c);
            boolean 		addAll(Collection<? extends E> c);
            boolean 		addAll(int index, Collection<? extends E> c);
            boolean 		removeAll(Collection<?> c);
            boolean 		retainAll(Collection<?> c);
            void 			clear();
            boolean 		equals(Object o);
            int 			hashCode();
            E 				get(int index);
            E 				set(int index, E element);
            void 			add(int index, E element);
            E 				remove(int index);
            int 			indexOf(Object o);
            int 			lastIndexOf(Object o);			//从右边的索引 
            ListIterator<E> listIterator();
            ListIterator<E> listIterator(int index);
            List<E> 		subList(int fromIndex, int toIndex);
            default void replaceAll(UnaryOperator<E> operator) {
                Objects.requireNonNull(operator);
                final ListIterator<E> li = this.listIterator();
                while (li.hasNext()) {
                    li.set(operator.apply(li.next()));
                }
            }

            @SuppressWarnings({"unchecked", "rawtypes"})
            default void sort(Comparator<? super E> c) {
                Object[] a = this.toArray();
                Arrays.sort(a, (Comparator) c);
                ListIterator<E> i = this.listIterator();
                for (Object e : a) {
                    i.next();
                    i.set((E) e);
                }
            }

            @Override
            default Spliterator<E> spliterator() {
                return Spliterators.spliterator(this, Spliterator.ORDERED);
            }
        }
        ```
        - Set 源码分析   
        	- 无序列表
        ```java
        public interface Set<E> extends Collection<E> {
                int 		size();
                boolean 	isEmpty();
                boolean 	contains(Object o);
                Iterator<E> iterator();
                Object[] 	toArray();
                <T> T[] 	toArray(T[] a);
                boolean 	add(E e);
                boolean 	remove(Object o);
                boolean 	containsAll(Collection<?> c);
                boolean 	addAll(Collection<? extends E> c);
                boolean 	retainAll(Collection<?> c);
                boolean 	removeAll(Collection<?> c);
                void 		clear();
                boolean 	equals(Object o);
                int 		hashCode();
                @Override
                default Spliterator<E> spliterator() {
                    return Spliterators.spliterator(this, Spliterator.DISTINCT);
                }
        }
        ```
        
        ```java
        public abstract class AbstractCollection<E> implements Collection<E> {
            public boolean contains(Object o) {
                Iterator<E> it = iterator();
                if (o==null) {
                    while (it.hasNext())
                        if (it.next()==null)
                            return true;			//只要是集合，都包含null
                } else {
                    while (it.hasNext())
                        if (o.equals(it.next()))	//判断o与集合元素是否相等
                            return true;
                }
                return false;
            }

            public Object[] toArray() {
                Object[] r = new Object[size()];
                Iterator<E> it = iterator();
                for (int i = 0; i < r.length; i++) {
                    if (! it.hasNext())
                        return Arrays.copyOf(r, i);		//深度复制元素
                    r[i] = it.next();
                }
                return it.hasNext() ? finishToArray(r, it) : r;
            }

            @SuppressWarnings("unchecked")
            public <T> T[] toArray(T[] a) {
                int size = size();
                T[] r = a.length >= size ? a :
                          (T[])java.lang.reflect.Array
                          .newInstance(a.getClass().getComponentType(), size);
                Iterator<E> it = iterator();

                for (int i = 0; i < r.length; i++) {
                    if (! it.hasNext()) {
                        if (a == r) {
                            r[i] = null;
                        } else if (a.length < i) {			//只复制T[] a长度的元素
                            return Arrays.copyOf(r, i);
                        } else {
                            System.arraycopy(r, 0, a, 0, i);
                            if (a.length > i) {
                                a[i] = null;
                            }
                        }
                        return a;
                    }
                    r[i] = (T)it.next();
                }
                // more elements than expected
                return it.hasNext() ? finishToArray(r, it) : r;
            }

            @SuppressWarnings("unchecked")
            private static <T> T[] finishToArray(T[] r, Iterator<?> it) {
                int i = r.length;
                while (it.hasNext()) {
                    int cap = r.length;
                    if (i == cap) {
                        int newCap = cap + (cap >> 1) + 1;
                        // overflow-conscious code
                        if (newCap - MAX_ARRAY_SIZE > 0)
                            newCap = hugeCapacity(cap + 1);
                        r = Arrays.copyOf(r, newCap);
                    }
                    r[i++] = (T)it.next();
                }
                // trim if overallocated
                return (i == r.length) ? r : Arrays.copyOf(r, i);
            }

            private static int hugeCapacity(int minCapacity) {
                if (minCapacity < 0) // overflow
                    throw new OutOfMemoryError
                        ("Required array size too large");
                return (minCapacity > MAX_ARRAY_SIZE) ?
                    Integer.MAX_VALUE :
                    MAX_ARRAY_SIZE;
            }

            public boolean removeAll(Collection<?> c) {
                Objects.requireNonNull(c);
                boolean modified = false;
                Iterator<?> it = iterator();
                while (it.hasNext()) {
                    if (c.contains(it.next())) {
                        it.remove();
                        modified = true;
                    }
                }
                return modified;
            }

            public boolean retainAll(Collection<?> c) {
                Objects.requireNonNull(c);
                boolean modified = false;
                Iterator<E> it = iterator();
                while (it.hasNext()) {
                    if (!c.contains(it.next())) {
                        it.remove();
                        modified = true;
                    }
                }
                return modified;
            }
        }
        ```
		- hash冲突的四种办法
	- 分布式
		- 问：项目中有用到MQ，主要是实现哪些功能？
		- 问：怎样判断mq中的方法成功执行了或者执行失败？
	- 缓存
	- 消息队列
	- 中间件
	- JVM
		- 模块或者结构图
		- java的垃圾回收机制？GC几种算法？GC Root？
		- 什么是虚函数，构造函数可以是虚函数吗，析构函数可以是虚函数吗?为什么？
		- interface的用法
		- JVM内存模型及调优
		- JAVA中堆栈和内存分配原理
		- JVM多太的原理
			- invokestatic  invokeinterface 等指令。常量池中的符号引用 找到直接引用。在堆中找到实例对象，获取到偏移量，由偏移量在方法表中指出调用的具体方法。接口是在方法表中进行扫描）
	- Spring
		- Spring IOC和Spring Aop如何设计与实现
		- Spring的annotation如何实现
		- 为什么要使用Spring呢？  
			- IOC就是依赖控制转化，利用JAVA的反射机制，将实例的初始化交给Spring。Spring可以通过配置文件管理实例。其实本质上还是因为IOC是通过反射机制来实现的。当我们的需求出现变动时，工厂模式会需要进行相应的变化。但是IOC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成的。
- nginx
	- 事件处理模型
- 算法
	- 拓扑排序思想
	- 红黑树知道吗？说一下红黑树的原理，红黑树能干什么？红黑树的旋转？
	- 图的 prime 算法   kruskal 算法  dijkstra算法  解决什么问题？
	- 如何判断一个整数是否是2的n次方幂？
	- 找到链表的倒数第K个节点
- 分布式
	- 分布式缓存
- 计算机网络
	- 熟悉网络通信机制及常用数据传输协议
	- http/tcp原理，tcp 3次握手4次挥手
- 数据库原理
	- 数据库优化（索引、存储引擎、sql优化、视图） 
	- mysql
	- Redis
		- Redis如何解决key冲突
			- redis都是保存的key.value的键值对。用的是hash对象，用拉链法解决hash过后的冲突。
	- 事务原理
	- 数据库加锁
- 操作系统
	- CPU调度算法
	- 内存管理
	- IO的几种类型和原理
	- 进程相关概念
	- 页面调度算法
	- 用户态和内核态
	- 数据库和文件系统
	- 进程通信的方法
	- Linux Shell
		- 库函数和内核调用吗？
- 计算机体系结构
	- 文件系统
- nodejs/js
- xml

- 书籍
    - 程序员的数学
    - Java编程思想
	- [书单](http://blog.jobbole.com/106093/)

- Java相关非专业知识
    - [Java 11 发布线路图](http://www.importnew.com/28380.html)
    - [JDK 10 的 109 项新特性](http://www.importnew.com/28364.html)

- 方案整合能力
- 数学
	- 蒙特卡洛方法知道吗？
	- 马尔可夫链知道吗？
- 其它
	- 项目
		- 开源代码的原理
		- 前端部署方案
		- 前端缓存方案
		- 并发中如何优化网络
		- 问：项目中有遇到哪些难点，是怎么克服的？
		- 问：简历上项目采用分布式开发，一共使用到了几个系统？
		- 问：怎样保证这两个系统中的数据同步？比如：用户下单后，需要在商品系统那边减库存，如何保证同步？(也就是分布式系统数据一致性)   
			- 很多分布式系统数据一致性都是采用MQ实现的
		- 问：zookeeper中都存储到哪些数据？
		- 问：用户管理系统中的数据采用了哪些储存技术？分别储存什么数据？

找P7的面试题
很多公司都说，先面试后定级，不过很多情况都是你投什么职位就会被定在什么职位区间。例如标记为高级/资深XX工程师，那面试流程就是按照P5-P6这个来，这个级别的面试一般只是组内技术面试官，组老大（可能是总监），HR面一下就决定了。
如果是面架构师/专家（P7），流程会不一样，一般是组内架构师/专家面，然后会是高级架构师/专家面，总监面，CTO/技术VP面，HR面。

![框架图](https://pic1.zhimg.com/v2-55b14cfd21efd783828bfa9543038c9c_r.jpg)




















